"use strict";(self.webpackChunkreact_tree_graph=self.webpackChunkreact_tree_graph||[]).push([[372],{"./.storybook/stories/animatedTree.stories.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Animations:()=>Animations,__namedExportsOrder:()=>__namedExportsOrder,default:()=>animatedTree_stories});var react=__webpack_require__("./node_modules/react/index.js"),quad=__webpack_require__("./node_modules/d3-ease/src/quad.js"),d3=__webpack_require__("./src/d3.js"),container=__webpack_require__("./src/components/container.js");function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}function Animated(props){const initialX=props.nodes[0].x,initialY=props.nodes[0].y,[state,setState]=(0,react.useState)({nodes:props.nodes.map((n=>({...n,x:initialX,y:initialY}))),links:props.links.map((l=>({source:{...l.source,x:initialX,y:initialY},target:{...l.target,x:initialX,y:initialY}})))}),[animation,setAnimation]=(0,react.useState)(null);function getClosestAncestor(node,stateWithNode,stateWithoutNode){let oldParent=node;for(;oldParent;){let newParent=stateWithoutNode.nodes.find((n=>areNodesSame(oldParent,n)));if(newParent)return newParent;oldParent=stateWithNode.nodes.find((n=>(props.getChildren(n)||[]).some((c=>areNodesSame(oldParent,c)))))}return stateWithoutNode.nodes[0]}function areNodesSame(a,b){return a.data[props.keyProp]===b.data[props.keyProp]}function areLinksSame(a,b){return a.source.data[props.keyProp]===b.source.data[props.keyProp]&&a.target.data[props.keyProp]===b.target.data[props.keyProp]}function calculateNewValue(start,end,interval){return start+(end-start)*props.easing(interval)}return(0,react.useEffect)((function animate(){clearInterval(animation);let counter=0;const animationContext=function getAnimationContext(initialState,newState){const addedNodes=newState.nodes.filter((n1=>initialState.nodes.every((n2=>!areNodesSame(n1,n2))))).map((n1=>({base:n1,old:getClosestAncestor(n1,newState,initialState),new:n1}))),changedNodes=newState.nodes.filter((n1=>initialState.nodes.some((n2=>areNodesSame(n1,n2))))).map((n1=>({base:n1,old:initialState.nodes.find((n2=>areNodesSame(n1,n2))),new:n1}))),removedNodes=initialState.nodes.filter((n1=>newState.nodes.every((n2=>!areNodesSame(n1,n2))))).map((n1=>({base:n1,old:n1,new:getClosestAncestor(n1,initialState,newState)}))),addedLinks=newState.links.filter((l1=>initialState.links.every((l2=>!areLinksSame(l1,l2))))).map((l1=>({base:l1,old:getClosestAncestor(l1.target,newState,initialState),new:l1}))),changedLinks=newState.links.filter((l1=>initialState.links.some((l2=>areLinksSame(l1,l2))))).map((l1=>({base:l1,old:initialState.links.find((l2=>areLinksSame(l1,l2))),new:l1}))),removedLinks=initialState.links.filter((l1=>newState.links.every((l2=>!areLinksSame(l1,l2))))).map((l1=>({base:l1,old:l1,new:getClosestAncestor(l1.target,initialState,newState)})));return{nodes:changedNodes.concat(addedNodes).concat(removedNodes),links:changedLinks.concat(addedLinks).concat(removedLinks)}}(state,props),interval=setInterval((()=>{if(counter++,counter===props.steps)return clearInterval(interval),void setState({nodes:props.nodes,links:props.links});setState(function calculateNewState(animationContext,interval){return{nodes:animationContext.nodes.map((n=>function calculateNodePosition(node,start,end,interval){return{...node,x:calculateNewValue(start.x,end.x,interval),y:calculateNewValue(start.y,end.y,interval)}}(n.base,n.old,n.new,interval))),links:animationContext.links.map((l=>function calculateLinkPosition(link,start,end,interval){return{source:{...link.source,x:calculateNewValue(start.source?start.source.x:start.x,end.source?end.source.x:end.x,interval),y:calculateNewValue(start.source?start.source.y:start.y,end.source?end.source.y:end.y,interval)},target:{...link.target,x:calculateNewValue(start.target?start.target.x:start.x,end.target?end.target.x:end.x,interval),y:calculateNewValue(start.target?start.target.y:start.y,end.target?end.target.y:end.y,interval)}}}(l.base,l.old,l.new,interval)))}}(animationContext,counter/props.steps))}),props.duration/props.steps);return setAnimation(interval),()=>clearInterval(animation)}),[props.nodes,props.links]),react.createElement(container.A,_extends({},props,state))}function animatedTree_extends(){return animatedTree_extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},animatedTree_extends.apply(null,arguments)}function AnimatedTree(props){const propsWithDefaults={direction:"ltr",duration:500,easing:quad.yv,getChildren:n=>n.children,steps:20,keyProp:"name",labelProp:"name",nodeShape:"circle",nodeProps:{},gProps:{},pathProps:{},svgProps:{},textProps:{},...props};return react.createElement(Animated,animatedTree_extends({duration:propsWithDefaults.duration,easing:propsWithDefaults.easing,getChildren:propsWithDefaults.getChildren,direction:propsWithDefaults.direction,height:propsWithDefaults.height,keyProp:propsWithDefaults.keyProp,labelProp:propsWithDefaults.labelProp,nodeShape:propsWithDefaults.nodeShape,nodeProps:propsWithDefaults.nodeProps,pathFunc:propsWithDefaults.pathFunc,steps:propsWithDefaults.steps,width:propsWithDefaults.width,gProps:{className:"node",...propsWithDefaults.gProps},pathProps:{className:"link",...propsWithDefaults.pathProps},svgProps:propsWithDefaults.svgProps,textProps:propsWithDefaults.textProps},(0,d3.A)(propsWithDefaults)),propsWithDefaults.children)}function animatedTree_stories_extends(){return animatedTree_stories_extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},animatedTree_stories_extends.apply(null,arguments)}Animated.__docgenInfo={description:"",methods:[],displayName:"Animated"},AnimatedTree.__docgenInfo={description:"",methods:[],displayName:"AnimatedTree"};const animatedTree_stories={title:"AnimatedTree/Animations",component:AnimatedTree,argTypes:__webpack_require__("./.storybook/stories/argTypes.js").z,parameters:{docs:{description:{component:"The AnimatedTree component has all the same props as the Tree component, and additional props to customise animation behaviour. Animations are automatically triggered when changes to the `data` prop are made. This demo works by using `setTimeout` to change the `data` prop every 2 seconds."}}}},order=[0,1,0,2],data=[{name:"Parent",children:[{name:"Child One"},{name:"Child Two"},{name:"Child Three",children:[{name:"Grandchild One"},{name:"Grandchild Two"}]}]},{name:"Child Three",children:[{name:"Grandchild One"},{name:"Grandchild Two"}]},{name:"Parent",children:[{name:"Child One"},{name:"Child Two"}]}],Animations={args:{height:400,width:600},parameters:{controls:{include:["duration","easing","steps"]}},render:args=>{const[position,setPosition]=(0,react.useState)(0);return(0,react.useEffect)((()=>{setTimeout((()=>setPosition(position>=order.length-1?0:position+1)),2e3)})),react.createElement(AnimatedTree,animatedTree_stories_extends({data:data[order[position]]},args))}},__namedExportsOrder=["Animations"];Animations.parameters={...Animations.parameters,docs:{...Animations.parameters?.docs,source:{originalSource:"{\n  args: {\n    height: 400,\n    width: 600\n  },\n  parameters: {\n    controls: {\n      include: ['duration', 'easing', 'steps']\n    }\n  },\n  render: args => {\n    const [position, setPosition] = useState(0);\n    useEffect(() => {\n      setTimeout(() => {\n        if (position >= order.length - 1) {\n          return setPosition(0);\n        }\n        return setPosition(position + 1);\n      }, 2000);\n    });\n    return <AnimatedTree data={data[order[position]]} {...args} />;\n  }\n}",...Animations.parameters?.docs?.source}}}}}]);